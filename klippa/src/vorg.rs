//! impl subset() for VORG
use crate::serialize::{SerializeErrorFlags, Serializer};
use crate::{Plan, Subset, SubsetError};
use write_fonts::{
    read::{tables::vorg::Vorg, FontRef, TopLevelTable},
    types::GlyphId,
    FontBuilder,
};

use fnv::FnvHashMap;

// reference: subset() for VORG in harfbuzz
// <https://github.com/harfbuzz/harfbuzz/blob/22fbc7568828b9acfd116be44b2d77d56d2d448b/src/hb-ot-vorg-table.hh#L90>
impl Subset for Vorg<'_> {
    fn subset(
        &self,
        plan: &Plan,
        _font: &FontRef,
        s: &mut Serializer,
        _builder: &mut FontBuilder,
    ) -> Result<(), SubsetError> {
        serialize(self, s, &plan.glyph_map).map_err(|_| SubsetError::SubsetTableError(Vorg::TAG))
    }
}

fn serialize(
    vorg: &Vorg,
    s: &mut Serializer,
    glyph_map: &FnvHashMap<GlyphId, GlyphId>,
) -> Result<(), SerializeErrorFlags> {
    s.embed(vorg.version())?;
    s.embed(vorg.default_vert_origin_y())?;

    let num_metrics_pos = s.embed(0_u16)?;

    let mut count: u16 = 0;

    for v_metrics in vorg.vert_origin_y_metrics().iter() {
        let old_gid = v_metrics.glyph_index();
        let Some(new_gid) = glyph_map.get(&GlyphId::from(old_gid)) else {
            continue;
        };
        s.embed(new_gid.to_u32() as u16)?;

        s.embed(v_metrics.vert_origin_y())?;

        count += 1;
    }
    s.copy_assign(num_metrics_pos, count);
    Ok(())
}

#[cfg(test)]
mod test {
    use super::*;
    use font_test_data::bebuffer::BeBuffer;
    use skrifa::raw::{FontData, FontRead};
    #[test]
    fn test_subset_vorg() {
        let raw_bytes: [u8; 280] = [
            0x00, 0x01, 0x00, 0x00, 0x03, 0x70, 0x00, 0x44, 0x1a, 0xf0, 0x03, 0x65, 0x1a, 0xf2,
            0x03, 0x67, 0x1a, 0xfb, 0x03, 0x66, 0x1a, 0xfc, 0x03, 0x67, 0x1a, 0xfe, 0x03, 0x67,
            0x1a, 0xff, 0x03, 0x67, 0x1b, 0x00, 0x03, 0x61, 0x1b, 0x01, 0x03, 0x67, 0x1b, 0x02,
            0x03, 0x67, 0x1b, 0x03, 0x03, 0x67, 0x1b, 0x04, 0x03, 0x67, 0x1b, 0x0c, 0x03, 0x67,
            0x1b, 0x0d, 0x03, 0x67, 0x1b, 0x0e, 0x03, 0x67, 0x1b, 0x0f, 0x03, 0x67, 0x1b, 0x10,
            0x03, 0x67, 0x1b, 0x11, 0x03, 0x67, 0x1b, 0x12, 0x03, 0x67, 0x1b, 0x13, 0x03, 0x67,
            0x1b, 0x14, 0x03, 0x67, 0x1b, 0x15, 0x03, 0x61, 0x1b, 0x16, 0x03, 0x67, 0x1b, 0x17,
            0x03, 0x67, 0x1b, 0x18, 0x03, 0x67, 0x1b, 0x19, 0x03, 0x67, 0x1b, 0x1a, 0x03, 0x67,
            0x1b, 0x1b, 0x03, 0x67, 0x1b, 0x1c, 0x03, 0x09, 0x1b, 0x1d, 0x03, 0x67, 0x1b, 0x1e,
            0x03, 0x67, 0x1b, 0x1f, 0x03, 0x67, 0x1b, 0x20, 0x03, 0x61, 0x1b, 0x21, 0x03, 0x67,
            0x1b, 0x22, 0x03, 0x67, 0x1b, 0x23, 0x03, 0x67, 0x1b, 0x24, 0x03, 0x67, 0x1b, 0x25,
            0x03, 0x67, 0x1b, 0x28, 0x03, 0xd4, 0x1b, 0x2a, 0x03, 0xd4, 0x1b, 0x2b, 0x03, 0x0d,
            0x1b, 0x2c, 0x03, 0x7e, 0x1b, 0x2d, 0x03, 0x0d, 0x1b, 0x2e, 0x03, 0x7e, 0x1b, 0x2f,
            0x03, 0x0d, 0x1b, 0x30, 0x03, 0x8a, 0x1b, 0x31, 0x02, 0x99, 0x1b, 0x32, 0x03, 0x84,
            0x1b, 0x33, 0x03, 0x92, 0x1b, 0x34, 0x03, 0x1e, 0x1b, 0x35, 0x03, 0x84, 0x1b, 0x36,
            0x03, 0x7e, 0x1b, 0x37, 0x03, 0x13, 0x1b, 0x38, 0x03, 0x13, 0x1b, 0x39, 0x03, 0x0d,
            0x1b, 0x3a, 0x02, 0xa7, 0x1b, 0x3b, 0x02, 0xa7, 0x1b, 0x3c, 0x03, 0x13, 0x1b, 0x3d,
            0x03, 0x0d, 0x1b, 0x3e, 0x03, 0x53, 0x1b, 0x3f, 0x03, 0x07, 0x1b, 0x40, 0x03, 0x0d,
            0x1b, 0x41, 0x03, 0x0d, 0x1b, 0x42, 0x03, 0x0d, 0x1b, 0x43, 0x02, 0x9d, 0x1b, 0x44,
            0x03, 0x0d, 0x1b, 0x49, 0x03, 0x65, 0x1f, 0xcb, 0x05, 0x64, 0x1f, 0xcc, 0x07, 0x58,
        ];
        let buf = BeBuffer::new().extend(raw_bytes);
        let vorg = Vorg::read(FontData::new(buf.data())).unwrap();

        let mut plan = Plan::default();
        plan.glyph_map.insert(GlyphId::NOTDEF, GlyphId::NOTDEF);
        plan.glyph_map.insert(GlyphId::new(6970), GlyphId::new(1));
        plan.glyph_map.insert(GlyphId::new(6971), GlyphId::new(2));
        plan.glyph_map.insert(GlyphId::new(6974), GlyphId::new(3));
        plan.glyph_map.insert(GlyphId::new(6980), GlyphId::new(4));

        let mut s = Serializer::new(1024);
        assert_eq!(s.start_serialize(), Ok(()));

        // unrelated font, font is actually unused in subset() method
        let font = FontRef::new(font_test_data::GLYF_COMPONENTS).unwrap();

        //builder is also not used
        let mut builder = FontBuilder::default();
        let ret = vorg.subset(&plan, &font, &mut s, &mut builder);
        assert!(ret.is_ok());

        s.end_serialize();
        assert!(!s.in_error());
        let subsetted_bytes = s.copy_bytes();
        let expected_bytes: [u8; 24] = [
            0x00, 0x01, 0x00, 0x00, 0x03, 0x70, 0x00, 0x04, 0x00, 0x01, 0x02, 0xa7, 0x00, 0x02,
            0x02, 0xa7, 0x00, 0x03, 0x03, 0x53, 0x00, 0x04, 0x03, 0x0d,
        ];
        assert_eq!(subsetted_bytes, expected_bytes);
    }
}
